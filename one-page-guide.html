---
layout: documentation
group: documentation
sub-group: one-pager
heading: one-pager
---

<h2>2: Introduction
</h2> 
<h2>2.1: Ebean
</h2> 
<p>Ebean is an open source Object Relational Mapping tool.
</p> 
<p>It's goal is to provide a simpler alternative to JPA (Java Persistence API) implementations such as Hibernate and Eclipselink.
</p> 
<p>It does this by providing a "sessionless" API and a simpler query language.
</p> 
<p>That means: 
</p> 
<ul><li>No Session Object (or UnitOfWork or EntityManager)</li>
<li>No Attached or Detached Beans</li>
<li>No merge(), persist(),  flush(), or clear().  Instead Ebean has save() and delete()</li>
</ul> 
<p>I have found (so far) that this is a bit hard for many people familiar with JPA / Hibernate / Eclipselink etc to get their head around. The short answer is that Ebean, just like JPA has a Persistence Context but has some architectural differences to allow it to have a different approach to the entity bean lifecycle and removing the need to manage EntityManagers.
</p> 
<h2>2.2: Why Ebean? ... why different from JPA?
</h2> 
<p>Ebean uses the JPA Mapping annotations and will follow those very closely.
</p> 
<p>However, Ebean has been architected and built from a different perspective than JPA. The Architectural and Query language differences are reasonably fundamental to both Ebean and JPA so its hard to see these differences going away anytime soon.
</p> 
<p>It becomes a question of whether this different approach taken by Ebean has technical merit and has made Ebean an easier ORM to understand and use. 
</p> 
<h2>2.2.1:  Architecture: Session / UnitOfWork / EntityManager 
</h2> 
<p>JPA is architected to use an "EntityManager" which closely matches a Hibernate "Session" and a Toplink "UnitOfWork". This brings with it the concepts that an entity bean can be attached or detached from the EntityManager (with associated merge, flush clear operations etc). If the EntityManager is used across multiple Transactions the EntityManager needs to be managed typically by a EJB Session Bean, Seam, Spring or similar container/framework.
</p> 
<p>Ebean is architected to not require an EntityManager (or Session or UnitOfWork object) with the goal of making it easier to use and to remove the requirement to manage 
</p> 
<p>
</p> 
<p>EntityManager objects (Aka a different approach to Lifecycle management).
</p> 
<p>Although Ebean doesn't have a EntityManager it <i><b>DOES</b></i> have a "Persistence Context" (like JPA) and by default in Ebean the persistence context is transaction scoped and automatically managed.
</p> 
<p>In my opinion this makes Ebean easier to understand and use.
</p> 
<h2>2.2.2:  Query Language
</h2> 
<p>JPA has defined a powerful query language. The issue with the query language is that I believe it will be difficult to evolve the language to support "Partial Objects" and generics (returning typed Lists/Sets etc) and this is due to specific issues with the JPQL select clause as it is currently defined.
</p> 
<p>Ebean has a simplier query language that I believe is more orientated to object graph construction. It has enabled Ebean to easily support "Partial Object" queries and return typed Lists Sets and Maps using generics.
</p> 
<p>It is my understanding the JPA expert group had discussed adding 'fetch groups' (which would be similar to Ebean's partial objects) to the JPA specification quite some time ago and decided not to. That is, they don't percieve the performance benefits to be worth the complexity. The Ebean expert group has a different opinion.
</p> 
<p>For Ebean "Partial Objects" are seen as an important feature from a performance stand point (fetch less from the database in a simple flexible manor) and from a design perspective (no need to change the design for "wide" objects and fol ow fixed designs based on "secondary" table properties and fixed annotations for eager or lazy loading) so there looks like a difference in opinion in this respect between JPA and Ebean.
</p> 
<p>In time it will be interesting to see how and if JPQL evolves and especially if there are moves for it to support "partial object" queries (possibly by introducing "fetch groups" into the JPA spec).
</p> 
<h2>2.2.3:  Why "Partial Objects" can greatly effect performance
</h2> 
<p>So, given JPA may not have "Partial Object" support in the query language for some time I'll just outline the reasons it is considered important for Ebean. They are pretty obvious except for what I describe as <i><b>"Index evaluation (database not having to read data blocks)".</b></i>
</p> 
<b>Per Use Case
</b> 
<p>Having "partial object" support in the query language means you can write a query that is optimal for each use case.  If you have fixed annotations to specify whether a property is lazy or eager loaded then you can not have optimal queries for a specific use cases (you will often end up with suboptimal queries).
</p> 
<p>
</p> 
<b>Clobs / Blobs
</b> 
<p>Clobs and Blobs are especially expensive and the ability to include/exclude clob/blob properties per use case/query can be significant in terms of performance.
</p> 
<b>Wide tables/entities – network cost
</b> 
<p>The wider you entities get the more cost is involved in fetching Gnd <b>ሀ</b>eading properties that a use case may never use. Some people have gone to various lengths to handle this issue such as having multiple representations of the same bean (to vertical y partition a wide entity). With "partial objects" you don't have to change your design if you hit a performance 'pain point'.
</p> 
<p>This cost is not only in terms of the database reading columns that are not required but in the extra network traffic involved in retrieving this data that is never used by that part of the application.
</p> 
<b>Index evaluation (database not having to read data blocks)
</b> 
<p>Something special happens when your SQL query only includes columns that are included in indexes. When this occurs the database can completely evaluate the query from the data held in the indexes and <i><b>NOT</b></i> have to read data blocks (obviously a generalisation on RDBMS internals but it's a good generalisation). 
</p> 
{% highlight java %}// database doesn't have to read the data blocks
// if "id" and "name" are in index(s)
select c.id, c.name
from customer c
where c.name like 'Rob%'
{% endhighlight %} 
<p>
</p> 
<p>If both the "id" and "name" columns are in indexes then the database could evaluate this query without having to read the data blocks. Compared to "Data blocks" "Index blocks" are more likely to be held in memory and smaler. 
</p> 
<p>BUT once you include a column that is not in an index then this doesn't hold – so surely this is not that useful. 
</p> 
<p>True, except something similar also occurs for joins where you only use columns on the joined table that are in an index(s).
</p> 
<p>For example, joining order_details to the products table and only using the product.name.
</p> 
{% highlight java %}// database doesn't have to read 'product' table data blocks
select o.*, d.*, p.name
from order o
join order_details d on d.order_id = o.id
join product p on p.id = d.product_id
where o.id = 27
{% endhighlight %} 
<p>So the part of the query evaluation relating to joining products can be performed by only reading the index – the data blocks for the product table do <i><b>NOT</b></i> have to be read.
</p> 
{% highlight java %}// the equivalent Ebean query
find order (*)
fetch details (*)
fetch details.product (name)
where id = 27
{% endhighlight %} 
<p>Now instead you may find more complex queries with many joins and you may be able to get this optimisation on a several of those joins. For example, add a join to customer to the example above just fetching the customer's name – now you get the optimisation on the join to product and on the join to customer. 
</p> 
<p>You may find this optimisation occuring a lot more than you think – for some queries that need to be faster you may even look to add an index (probably a compound index) to target this optimisation specifically (to support a autocompletion UI control for example).
</p> 
<p>Overal , what this means is that "partial object" queries can result in either al  or part of the query being evaluated by the database via data held in indexes without the database needing to read data blocks. For large databases this can be a very significant performance optimization. If you need this Ebean has made it very easy without requiring a change to your design (either ORM or Database design).
</p> 
<p>To be fair most of the major ORM's provide similar functionality via "Fetch Groups". It is not JPA standard yet (and IMO not as elegant as "partial objects") but is probably worth investigating if you are using one of those products.
</p> 
<p>Currently as I see it, the differences between Ebean's "partial objects" and "Fetch Groups" is that "Fetch Groups" seem to have limitations such as being read only (can't modify and save), and don't allow further lazy loading. Ebean's "partial objects" are really easy to use and can be treated just like other entity beans with lazy loading and support for being saved.
</p> 
<h2>2.2.4:  All the missing bits
</h2> 
<p>JPA is a developing specification but in my opinion it leaves a lot of very useful features out. This includes partial objects, batching control, support for large queries (row level persistence context), background fetching, caching control, transaction isolation.
</p> 
<p>
</p> 
<p>It also has "interesting" support for using raw SQL – in my opinion Ebean makes using raw SQL much easier. In my experience there are some tasks that are more natural y done in a Relational way. 
</p> 
<p>Obviously JPA will evolve and may look to support some of these features in the future. In the meantime, if you are using JPA do not be surprised if you need to use vendor specific features.
</p> 
<h2>2.3: Ibatis 
</h2> 
<p>ORM is neat but at the same time we should remember that there are times when it is easier/better/faster to have direct control over the SQL. Ibatis is such a tool and very popular with this in mind.
</p> 
<p>Part of Ebean's goal is to make using your own SQL easy (easier than Ibatis is the goal for Ebean). The @SqlSelect feature goes a long way to doing this along with SqlUpdate and CallableSql objects.
</p> 
<p>
</p> 
<h2>3: Ebean and EbeanServer
</h2> 
<p>Ebean and EbeanServer are the objects that provide the main API to find and save entities etc. It is worth quickly explaining what they are and how they relate.
</p> 
<p><i><b>EbeanServer</b></i>
</p> 
<ul><li>This provides the main API</li>
<li>There is one EbeanServer per DataSource</li>
<li>One of the EbeanServer's can be nominated as the "Default" EbeanServer</li>
<li>A EbeanServer can be 'registered' with the Ebean singleton when it is created. This means it can later be accessed via: </li>
</ul> 
<p>EbeanServer s = Ebean.getServer(serverName);
</p> 
<p><i><b>Ebean (singleton)</b></i>
</p> 
<ul><li>Is a Singleton</li>
<li>Holds a map of EbeanServer's</li>
<li>Provides methods that proxy through to the "Default" EbeanServer. This is convienient for applications that use a single DataSource.</li>
<li>i.e. Ebean.find(Person.class, 7); actual y cal s the find method on the "Default" EbeanServer....  Ebean.getServer(null).find(Person.class, 7);</li>
</ul> 
<p>Most of the examples in this document will use Ebean (the singleton) rather than EbeanServer. 
</p> 
{% highlight java %}// Using Ebean (singleton)... 
Customer customer = Ebean.find(Customer.class, 4);
// Is equivalent to...
EbeanServer defaultServer = Ebean.getServer(null);
Customer customer = defaultServer.find(Customer.class, 4);
{% endhighlight %} 
<p>
</p> 
<h2>4: Features Overview
</h2> 
<h2>4.1.1:  Mapping
</h2> 
<p>Ebean uses the same mapping as per the JPA specification. So you annotate your beans with @Entity, @Table, @Column, @OneToMany etc as per the JPA specification.
</p> 
<p>The Mapping is covered in detail in section 
</p> 

<h2>4.1.5:  Save &amp; Delete
</h2> 
<p>Saving and deleting is just a matter of calling the Ebean.save() or Ebean.delete() methods.  Transaction demarcation is covered fully in<a href="ebean-userguides.html#14"> 6. Transactions </a>.  Note if no transaction currently exists one will be created and commited for you (or rolled back if there was an error).
</p> 
{% highlight java %}Order order = Ebean.find(Order.class, 12);
order.setStatus(OrderStatus.SHIPPED);order.setShipDate(...);
// this will save the order
Ebean.save(order);
{% endhighlight %} 
<p>
</p> 
<b>Cascading Save &amp; Delete
</b> 
<p>The mapping annotations @ManyToOne, @OneToMany, @OneToOne and @ManyToMany provide a cascade attribute which is used to control whether saves and deletes are cascaded.
</p> 
<p>
</p> 
<p>The default is to not cascade a save or delete (as per JPA spec).
</p> 
<p>The example below shows the Order entity bean with its mapping annotations. If you save an Order the details will be saved as well but the associated customer will not be saved as there is no cascade atttribute and the default is to not cascade. 
</p> 
{% highlight java %}...
@Entity
@Table(name="or_order")
public class Order {
    ...
// no cascading
    @ManyToOne
    Customer customer;
// save and delete cascaded
    @OneToMany(cascade=CascadeType.ALL)
List<OrderDetail> details;
{% endhighlight %} 
<p>
</p> 
<h2>4.1.6:  Update
</h2> 
<p>Update provides a way on issuing a insert, update or delete statement. 
</p> 
<p>This is useful for updating or deleting multiple rows (or a single row) with a single statement (often described as a "bulk" update).
</p> 
<p>This is also useful if you want to perform an update or delete without having to execute a query first. This is a typical approach for performing an update in a stateless web application.
</p> 
<p>The statement can be provided in as raw DML with the table names and column names or in a 'logical' form where entity name is used in place of the table name and property names are used in place of column names.
</p> 

<h2>5: Relational Features
</h2> 
<p>Object Relational Mapping is great but it is also possible some of your problems will be easier to tackle in a relational way. Ebean provides a set of relational features so that you choose a relational approach as you see fit.
</p> 
<h2>5.1.1:  SqlQuery
</h2> 
<p>SqlQuery is where you specify the exact SQL SELECT statement and returns list, sets or maps of SqlRow objects. A SqlRow is a Map where the key is the column name.
</p> 
<p>This is a fairly lightweight API that you could use instead of going to raw JDBC (which is of course an option).
</p> 
{% highlight java %}String sql = "select b.id, b.title, b.type_code, b.updtime"
+" ,p.name as product_name "
+"from b_bug b join b_product p on p.id = b.product_id "+"where b.id = :id";
SqlRow bug = Ebean.createSqlQuery(sql)
.setParameter("id", 1).findUnique();
String prodName = bug.getString("product_name");
String title = bug.getString("title");
{% endhighlight %} 
<p>Note that you can use "Named" queries and put the sql statements in orm.xml rather than having it in your code.
</p> 
<h2>5.1.2:  SqlUpdate
</h2> 
<p>In similar fashion to SqlQuery you can specify a SQL INSERT, UPDATE or DELETE statement with named or positioned parameters.
</p> 
{% highlight java %}String dml = "update b_bug set title=:title where id = :id";
SqlUpdate update = Ebean.createSqlUpdate(dml)
.setParameter("title", "Updated Again").setParameter("id", 1);
int rows = update.execute();
{% endhighlight %} 
<p>
</p> 
<h2>5.1.3:  CallableSql
</h2> 
<p>CallableSql provides a way to cal  a database stored procedure.
</p> 
{% highlight java %} String sql = "{call sp_order_mod(?,?)}";
CallableSql cs = Ebean.createCallableSql(sql);
cs.setParameter(1, "turbo");
cs.registerOut(2, Types.INTEGER);
Ebean.execute(cs);
// read the out parameter Integer returnValue = (Integer) cs.getObject(2);
{% endhighlight %} 
<p>You can extend CallableSql and you can also get the java.sql.Connection from a Transaction and use raw JDBC API to call a stored procedure. 
</p> 
<h2>5.1.4:  Summary
</h2> 
<p>These relational features provide an alternative "relational" approach to the ORM features without resorting to direct JDBC use.
</p> 
<p>
</p> 
<h2>5.2: Raw JDBC 
</h2> 
<p>You can't always predict when your application requirements can't be meet with the features in Ebean. It is nice you now you can easily use raw JDBC if and when you need to.
</p> 
<p>The java.sql.Connection object can be returned from a transaction, and with that you can perform any raw JDBC cal s you like. 
</p> 
<p>This may be useful for Savepoints, advanced Clob/Blob use or advanced stored procedure calls (if CallableSql doesn't do the business for you).
</p> 
{% highlight java %}Transaction transaction = Ebean.beginTransaction();try {
Connection connection = transaction.getConnection();
// use raw JDBC
...
 // assuming we updated the "o_shipping_details" table
 // inform Ebean so it can maintain its 'L2' cache
 transaction.addModification("o_shipping_details",false,true,false);
Ebean.commitTransaction();
} finally {
Ebean.endTransaction();
}
{% endhighlight %} 
<p>The <i><b>transaction.addModification() </b></i>in the code above informs Ebean that your jdbc code updated the o_shipping_details table.  Ebean uses this information to automatically manage its "L2" cache as well as maintain Lucene text indexes.
</p> 
<p>
</p> 
<h2>6: Queries
</h2> 
<h2>6.1: Background
</h2> 
<p>Ebean has it's own query language. Prior to this decision JPQL (the JPA query language) was investigated to see if it would meet the desired goals of Ebean and it did not. Specifically I wanted to support "Partial Objects" via the query language and it is difficult to see how JPQL will evolve to support this (specifical y difficulties around its select clause). 
</p> 
<p>Apart from "Partial Object" support there was also a desire to simplify the join syntax, specifically Ebean will automatically determine the type of join (outer join etc) for you and also automatical y add joins to support predicates and order by clauses.
</p> 
<p>JPQL is more powerful with the ability to mix entity beans with scalar values returning Object[]. However, this feature also could be a major stumbling block for it to evolve support for partial objects for any node in the object graph.
</p> 
<p>In summary you could say the Ebean query language is much simplier that JPQL with the benefit of proper support for "Partial Objects" for any node in the object graph (this is not possible with JPQL in it's current form).
</p> 
<p><b>"Partial Object"</b> support in Ebean is important for design reasons and performance reasons. From a performance perspective your queries are more performant if they fetch less data back from the database. From a design perspective you do not need to model using secondary tables but instead use partial objects at any depth in the query.
</p> 
<p>For example, to build an object graph for an Order you may want some product information for each orderDetail.
</p> 
<h2>6.2: Examples
</h2> 
{% highlight java %}// find all the orders fetching all the properties of order
find order 
// find all the orders fetching all the properties of order
// ... this is the same as the first query
find order (*)
// find all the orders fetching the id, orderDate and shipDate
// ... This is described as a "partial object query"
// ... the ID property is *ALWAYS* fetched
find order (orderDate, shipDate)
// find all the orders (and orderDetails)
// ... fetching all the properties of order
// ... and all the properties of orderDetails
// ... the type of fetch(Outer etc) is determined automatically
find  order
fetch orderDetails
// find all the orders (with their orderDetails)
// ... fetching all the properties of order
// ... and all the properties of orderDetails
find  order (*)
fetch orderDetails (*)
// find all the orders (with orderDetails and products)
// ... fetching the order id, orderDate and shipDate
// ... fetching all the properties for orderDetail
// ... fetching the product id, sku and name
find  order (orderDate, shipDate)
fetch orderDetails (*)
fetch orderDetails.product (sku, name)
{% endhighlight %} 
<p>Every object in the object graph can be a partial object. This is what you can't do in JPQL yet and it's hard to see how this will be supported in JPQL due to its design – hopefully I'm wrong on this point.  
</p> 
<p>These Partial y populated objects are will lazy load as required and are fully updatable etc. You can treat them just like fully populated objects.
</p> 
<p>Autofetch can use partial objects to only fetch the properties that the application actual y uses. In this way you can get the performance of partial objects without any work on your part (Autofetch determines the joins and properties to fetch for you).
</p> 
{% highlight java %}// Ebean will automatically add joins to support
// where clauses and order by clauses as necessary
// ... in this case a join to customer is added
// ... and a join to the customers billing address is added
find order
where customer.name like :custname
order by customer.billingAddress.city
// you can use an order by and limit offset clause
find order
where customer.name like :custname
order by customer.name desc, id
limit 10 offset 20
// You can use +readonly hint on any part of the object graph
// ... which means those objects are not modifyable
find customer (+readonly)
fetch billingAddress (+readonly, line1, city)
{% endhighlight %} 
<p>
</p> 
<h2>6.3: API: createQuery(Class c) and find(Class c)
</h2> 
<p>This needs a little clarification.
</p> 
{% highlight java %}// these are the same
Query<Order> query = Ebean.createQuery(Order.class); 
Query<Order> query = Ebean.find(Order.class); 
{% endhighlight %} 
<p>This may be confusing but these two methods do exactly the same thing. The reason both exist is because the createQuery() style is consistent with JPA and could be argued is a better more accurate name. However, I feel that find() is more consistent with the fluid API style.
</p> 
<p>So, apologies in that there are 2 ways to do the same thing. 
</p> 
{% highlight java %}// fluid API style with find()
List<Order> list =
Ebean.find(Order.class).fetch("customer").where().eq("status.code", "SHIPPED").findList();
{% endhighlight %} 
<h2>6.4: Named Queries
</h2> 
{% highlight java %}...
@NamedQueries(value={
  @NamedQuery(
  name="bugsSummary"
,query="find (name, email) fetch loggedBugs (title, status) 
  where id=:id  "),
  @NamedQuery(
name="bugStatus",
    query="fetch loggedBugs where loggedBugs.status = :bugStatus
           order by name")
})
@Entity
@Table(name="s_user")
public class User implements Serializable {
...
{% endhighlight %} 
<p>You can have named queries, where you define the query. Note that the names of the queries are per entity type (not global as they are in JPA).
</p> 
<p>Once you get a named query you set any named parameters and then execute it – in the case below we use findUnique() as we expect only one object graph returned.
</p> 
{% highlight java %}User u = Ebean.createNamedQuery(User.class, "bugsSummary")
.setParameter("id", 1)
.findUnique();
{% endhighlight %} 
<p>
</p> 
<h2>6.4.1:  Named Queries are Modifyable
</h2> 
<p>Named queries are parsed early and returned as query objects to you that you can modify. This means that you can get a named query and then modify the query by adding to the where clause, setting the order by, limits etc. 
</p> 
<p>
</p> 
<p>This is an intentional feature and means that you can use Named Queries as a "starting point" to then modify via code and execute.  
</p> 
{% highlight java %}// you can treat namedQueries as starting points... 
// ... in that you can modify them via code
// ... prior to executing the query
// you can modify a named query...
Set<User> users = Ebean.createQuery(User.class, "bugStatus")
.setParameter("bugStatus", "NEW")
// you can add to the where clause
.where().ilike("name", "rob%")
// you can set/override the order by
.orderBy("id desc")
// you can set/override limits (max rows, first row)
.setMaxRows(20)
.findSet();
{% endhighlight %} 
<p>
</p> 
<h2>6.5: FetchConfig - "Query Joins"
</h2> 
<p>When you specify a Query with Ebean it can result in more than 1 SQL query. Sometimes you want explicit control over this (what the secondary queries are, batch size used, eager or lazily invoked)
</p> 
<p>FetchConfig gives you the ability to specify these "secondary queries" and let them executed lazily ("lazy loading join") or eagerly ("query join"). 
</p> 
<p>Note that Ebean will automatically convert some joins to "query joins" when it needs to (when it is building object graphs with multiple *ToMany relationships or when limit offset is used with a *ToMany relationship). So you don't need to explicitly use FetchConfig and leave it up to Ebean if you wish. 
</p> 
<p>Example: Normal "Fetch Join"
</p> 
{% highlight java %}// Orders and their customers fetch in a single SQL query
List<Order> l0 = Ebean.find(Order.class)
   .fetch("customer")
   .findList();
{% endhighlight %} 
<p>Example: "Query Join" … results in 2 SQL queries used to build the object graph
</p> 
{% highlight java %}// 2 SQL statements are used to build this object graph
// The first SQL query fetches the Orders and the second
// SQL query fetches customers
List<Order> l0 = Ebean.find(Order.class)
   .fetch("customer", new FetchConfig().query())
   .findList();
{% endhighlight %} 
<p>The reason for using "Query Joins" as opposed to "Fetch joins" is that there are some cases where using multiple queries is more efficient that a single query.
</p> 
<p>Any time you want to load multiple OneToMany associations it will likely be more performant as multiple SQL queries. If a single SQL query was used that would result in a Cartesian product. 
</p> 
<p>There can also be cases loading across a single OneToMany where 2 SQL queries (using Ebean "query join") can be more efficient than one SQL query (using Ebean "fetch join"). When the "One" side is wide (lots of columns) and the cardinality difference is high (a lot of "Many" beans per "One" bean) then this can be more efficient loaded as 2 SQL queries. 
</p> 
<p>
</p> 
<p>Example: Two "Query Joins" results in 3 SQL queries used to build this object graph
</p> 
{% highlight java %}// A more advanced example with multiple query joins
List<Order> l0 = Ebean.find(Order.class)
 .select("status, shipDate")
.fetch("details", "orderQty, unitPrice", new FetchConfig().query())
 .fetch("details.product", "sku, name")
.fetch("customer", "name", new FetchConfig().query(10))
.fetch("customer.contacts","firstName, lastName, mobile")
 .fetch("customer.shippingAddress","line1, city")
 .findList();
{% endhighlight %} 
<p>The resulting 3 sql queries are:
</p> 
{% highlight java %}// query 1 … the main query
<sql summary='Order' >
select o.id c0, o.status c1, o.ship_date c2, o.customer_id c3
from o_order o</sql>
{% endhighlight %} 
<p>Query 1 - Note: customer_id was automatical y added to support query join.
</p> 
{% highlight java %}// query 2 … query join on customer
<sql mode='+query' summary='Customer, shippingAddress
+many:contacts' load='path:customer batch:10 actual:2' >
select c.id c0, c.name c1
        , cs.id c2, cs.line_1 c3, cs.city c4
        , cc.id c5, cc.first_name c6, cc.last_name c7, cc.mobile c8 
from o_customer c
left outer join o_address cs on cs.id = c.shipping_address_id
left outer join contact cc on cc.customer_id = c.id 
where c.id in (?,?,?,?,?,?,?,?,?,?)
order by c.id
</sql>
{% endhighlight %} 
<p>Query 2 - fetching the first 10 customers referenced (batch:10) but there where actual y only 2 to fetch (actual:2).
</p> 
<p>
</p> 
{% highlight java %}// query 3 … query join on details
<sql mode='+query' summary='Order +many:details, details.product'
load='path:details batch:100 actual:3' >
select o.id c0
        , od.id c1, od.order_qty c2, od.unit_price c3
        , odp.id c4, odp.sku c5, odp.name c6
from o_order o
left outer join o_order_detail od on od.order_id = o.id
left outer join o_product odp on odp.id = od.product_id 
where o.id in (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
order by o.id</sql>
{% endhighlight %} 
<p>Query 3 – fetching the order details for the first 100 orders (batch:100).
</p> 
<h2>6.5.1:  FetchConfig.lazy() - "Lazy Joins"
</h2> 
<p>If a join is not defined at al  (neither a fetch join or a query join) – then lazy loading will by default just fetch al  the properties for that entity.
</p> 
<p>FetchConfig.lazy() allows you to control that lazy loading query – define the batch size, properties to select and also fetch paths to include on the lazy load query. 
</p> 
<p>This is very similar to a "query join" except that the loading occurs on demand (when the property is requested and not already loaded).
</p> 
<p>The reason you would want to control the lazy loading query is to optimise performance for further lazy loading (avoid N+1 queries, define joins that should be included for lazy loading queries, load only the properties required and no more).
</p> 
<p> 
</p> 
<p>Example: Control the query used to lazy load 
</p> 
{% highlight java %}// control the lazy loading of customers ...
List<Order> list = Ebean.find(Order.class)
   .fetch("customer","name", new FetchConfig().lazy(5))
   .fetch("customer.contacts","contactName, phone, email")
   .fetch("customer.shippingAddress")
   .where().eq("status",Order.Status.NEW)   .findList();
{% endhighlight %} 
<p>In the example above the orders are loaded. Only when the application requests a 
</p> 
<p>customer property (that is not the customer's id) then the lazy loading of the customer is invoked. At that point the customer name is loaded, with the contacts and shippingAddress – this is done in batch of 5 customers.
</p> 
<p>Note that if the customer status is requested (rather than the customer name) and that invokes the lazy loading then all the customer's properties are loaded (rather than just the customers name). 
</p> 
{% highlight java %}Order order = list.get(0);Customer customer = order.getCustomer();
// this invokes the lazy loading of 5 customersString name = customer.getName();
{% endhighlight %} 
<p>The resulting lazy loading query is … 
</p> 
{% highlight java %}<sql mode='+lazy' summary='Customer, shippingAddress +many:contacts'
load='path:customer batch:5 actual:2' >
select c.id c0, c.name c1
        , cs.id c2, cs.line_1 c3, cs.line_2 c4, cs.city c5,
cs.cretime c6, cs.updtime c7, cs.country_code c8
        , cc.id c9, cc.phone c10, cc.email c11 
from o_customer c
left outer join o_address cs on cs.id = c.shipping_address_id
{% endhighlight %} 
<p><b>left outer join contact cc on cc.customer_id = c.id</b> 
</p> 
{% highlight java %}where c.id in (?,?,?,?,?)
order by c.id
</sql>
{% endhighlight %} 
<p>
</p> 
<h2>6.5.2:  Using both - new FetchQuery.queryFirst(100).lazy(10);
</h2> 
<p>You can use both queryFirst() and lazy() on a single join. The queryFirst() part defines the number of beans that will be loaded eagerly via an additional query and then lazy defines the batch size of the lazy loading that occurs after than (if there is any).
</p> 
<h2>6.5.3:  +query and +lazy – query language syntax
</h2> 
<p>To define "query joins" and "lazy joins" in the query language you can use +query and +lazy. Optionally you can specify the batch size for both.
</p> 
<p>
</p> 
{% highlight java %}find order
join customers (+query )
where status = :status
find order (status, shipDate)
join customers (+lazy(10)  name, status)
where status = :orderStatus
{% endhighlight %} 
<p>
</p> 
<h2>6.6: Asynchronous Query Execution – findFutureList() etc
</h2> 
<p>Ebean has built in support for executing queries asynchronously. These queries are executed in a background thread and "Future" objects are returned. 
</p> 
<p>The "Future" objects returned extend <i><b>java.util.concurrent.Future</b></i>. This provides support for cancel ing the query, checking if it is cancel ed or done and getting the result with waiting and timeout support. 
</p> 
{% highlight java %}// Methods on Query for ansychronous execution
public FutureList<T> findFutureList();
public FutureIds<T> findFutureIds();
public FutureRowCount<T> findFutureRowCount();
{% endhighlight %} 
<p>Example: Using FutureList
</p> 
{% highlight java %}Query<Order> query = Ebean.find(Order.class);
// find list using a background threadFutureList<Order> futureList = query.findFutureList();
// do something else ...
if (!futureList.isDone()){
{% endhighlight %} 
<p><b>// you can cancel the query. If supported by the JDBC</b> 
</p> 
{% highlight java %}// driver and database this will actually cancel the
// sql query execution on the database
futureList.cancel(true);
}
// wait for the query to finish … no timeout
List<Order> list = futureList.get();
// wait for the query to finish … with a 30sec timeout
List<Order> list2 = futureList.get(30, TimeUnit.SECONDS);
{% endhighlight %} 
<h2>6.7: PagingList Query
</h2> 
<p>PagingList is used to make it easy to page through a query result. Paging through the results means that instead of all the results are not fetched in a single query Ebean will use SQL to limit the results (limit/offset, rownum, row_number() etc).
</p> 
<p>Instead of using PagingList you could just use setFirstRow() setMaxRows() on the query yourself. If you are building a stateless application (not holding the PagingList over multiple requests) then this approach is a good option.
</p> 
<p>For Stateful applications PagingList provides some benefits.
</p> 
<ul><li>Fetch ahead (background fetching of the next page via a FutureList query)</li>
<li>Automatic propagation of the persistence context</li>
<li>Automatically getting the total row count (via a FutureRowCount query)</li>
</ul> 
<p>So with PagingList when you use Page 2 it will automatical y fetch Page 3 data in the background (using a FutureList query). The persistence context is automatical y propagated meaning that all the paging queries use the same persistence context.
</p> 
{% highlight java %}int pageSize = 10;
PagingList<TOne> pagingList = 
Ebean.find(TOne.class)
.where().gt("name", "2").findPagingList(pageSize);
// get the row count in the background...
// ... otherwise it is fetched on demand
// ... when getTotalRowCount() or getTotalPageCount()
// ... is called
pagingList.getFutureRowCount();
// get the first page
Page<TOne> page = pagingList.getPage(0);
// get the beans from the page as a list
List<TOne> list = page.getList();
int totalRows = page.getTotalRowCount();
if (page.hasNext()) {
Page<TOne> nextPage = page.next();
...
}
{% endhighlight %} 
<p>In a stateless application you should set fetch ahead to false as you are not going to benefit from it.
</p> 
{% highlight java %}PagingList<TOne> pagingList = 
Ebean.find(TOne.class)
.where().gt("name", "2")
.findPagingList(10);
// fetchAhead not useful in a stateless application
pagingList.setFetchAhead(false);
Page<TOne> firstPage = pagingList.getPage(0);
{% endhighlight %} 
<p>
</p> 

<h2>8: Persistence Context
</h2> 
<p>Although Ebean doesn't have an "Entity Manager" it does have a "persistence context". In fact, you could go as far to say that any ORM worth using needs a "persistence context".
</p> 
<h2>8.1: Definition
</h2> 
<p>JPA v1.0 specification - section 5.1
</p> 
<p>"A persistence context is a set of managed entity instances in which <i>for any persistent entity <b>identity</b>there is a <b>unique entity instance</b></i>. Within the persistence context, the entity instances and their lifecycle are managed by the entity manager."
</p> 
<p>Ebean has a "Persistence Context" to ensure ... unique entity instances <i><b>BUT</b></i> Ebean has a different approach to lifecycle management.
</p> 
<p>That is, Ebean has a persistence context to ensure "... unique entity instance." (the blue section of JPA's definition) but has a different approach to the lifecycle management compared with JPA. Ebean has no entity manager and no persist/merge/flush lifecycle methods.
</p> 
<h2>8.2: Unique Entity Instances
</h2> 
<p>Ebean uses the "persistence context" for queries and lazy loading (when it is building object graphs). The purpose of this is to ensure that 'consistent' object graphs are constructed (1 unique instance per identity).
</p> 
<p>For example, in fetching a list of orders and their customers … the persistence context ensures that you only get 1 customer instance for it's given id (e.g. you are <i><b>NOT</b></i> al owed to have 2 or more instances of "customer id=7".
</p> 
<p>You could even say that any ORM worth using needs a persistence context when it builds object graphs from relational result sets due to the nature of relational result sets.   
</p> 
<p>For example, if you didn't have a persistence context and did al ow 2 or more instances of "customer 7" … and modified one instance but not the other … things get very ugly. The "persistence context" ensures the user/application code works with unique entity instances.
</p> 
<h2>8.3: Lifecycle Management 
</h2> 
<p>Ebean has a different approach to lifecycle management. The core difference is that with Ebean each bean itself has it's own dirty checking (detects when it has been modified and holds it's old/original values for optimistic concurrency checking).
</p> 
<p>With JPA implementations generally the dirty checking is performed by the entity manager. The entity manager general y holds the old/original values for optimistic concurrency checking and the beans need to be 'attached' to an entity manager to be 'flushed' (as an 
</p> 
<p>
</p> 
<p>insert/update/delete). [Note: JDO based JPA implementations do this a bit differently]. 
</p> 
<b>PRO's for Ebean's approach
</b> 
{% highlight java %}<li>No need to manage Entity Manager's</li>
<li>save/delete simpler that attached/detached beans with persist/merge/flush etc</li>
CON's for Ebean's approach
<li>Ebean makes an assumption that scalar types are immutable. Most scalar types (String, Integer, Double, Float, BigDecimal etc) are immutable, however, some such as java.util.Date are not. What this means is that with Ebean if you mutate a java.util.Date Ebean will <i><b>NOT</b></i> detect the change  – instead you have to set a different java.util.Date instance.</li>
{% endhighlight %} 
<h2>8.4: Transaction scoped
</h2> 
<p>With Ebean the persistence context is transaction scoped. This means that when you begin a new transaction (implicitly or explicitly) Ebean will start a new persistence context.
</p> 
<p>The persistence context uses weak references and lives beyond the end of a transaction. This enables any lazy loading occuring after the transaction ends to use the same persistence context that the instance was created with.
</p> 
<p>This means, a persistence context 
</p> 
<ul><li>Starts when a transaction starts</li>
<li>Is used during the transactions scope to build all object graphs (queries)</li>
<li>Lives beyond the end of a transaction so that all lazy loading occuring on that object graph also uses the same persistence context</li>
</ul> 
<h2>8.5: Multi-threaded object graph construction
</h2> 
<p>The persistence context is designed/implemented to be thread safe. Ebean internally can use multiple threads for object graph construction (query execution) and I expect some advanced users to take an interest in this (and may want to do this in their own application code).    
</p> 
<p>When Ebean uses background threads for fetching (findFutureList,  PagingList, useBackgroundFetchAfter etc) Ebean will automatical y propagate the persistence context. In these cases multiple threads can be using the same persistence context concurrently.
</p> 
<p>This also enables Ebean to provide more advanced multi-threaded query strategies in the future.
</p> 
<h2>8.6: Persistence Context as a "first level cache"
</h2> 
<p>The persistence context is sometimes described as the "first level cache". I have also seen 
</p> 
<p>
</p> 
<p>it described as the "transactional cache" in that it is scoped to a transaction or longer.
</p> 
<p> 
</p> 
{% highlight java %}// a new persistence context started with the transaction
Ebean.beginTransaction();try {
// find "order 72" results in that instance being put
// into the persistence context
Order order = Ebean.find(Order.class, 72);
// finds an existing "order 72" in the persistence context
// ... so just returns that instance
Order o2 = Ebean.find(Order.class, 72);
Order o3 = Ebean.getReference(Order.class, 72);
// all the same instance
Assert.assertTrue(order == o2);
Assert.assertTrue(order == o3);
} finally {
Ebean.endTransaction();
}
{% endhighlight %} 
<p>The code above shows that  there is only 1 instance of "Order 72". As we try to fetch it again (during the scope of a single persistence context) we end up getting back the same instance.
</p> 
<p>However, typically you don't write code that fetches the same Order multiple times in a single transaction. The code above is not something you would typical y write.
</p> 
<p>A more realistic example would be when the persistence context is used:
</p> 
{% highlight java %}// a new persistence context started with the transaction
Ebean.beginTransaction();try {
// find "customer 1" results in this instance being
// put into the persistence context
Customer customer = Ebean.find(Customer.class, 1);
// for this example … "customer 1" placed "order 72"
// when "order 72" is fetched/built it has a foreign// key value customer_id = 1...
 
// As customer 1 is already in the persistence context// this same instance of customer 1 is used  
{% endhighlight %} 
<p>
</p> 
{% highlight java %}Order order = Ebean.find(Order.class, 72);Customer customerB = order.getCustomer();
// they are the same instanceAssert.assertTrue(customer == customerB);
} finally {
Ebean.endTransaction();
}
{% endhighlight %} 
<p> 
</p> 
<p>From these examples you should hopefully see that the persistence context acts as a cache to some degree. It can sometimes reduce the number of database queries required when you get object graphs and navigate them.
</p> 
<p>However, the primary function of the persistence context is to ensure ... unique instances for a given identity (so that the object graphs are constructed in a consistent manor). The fact that it sometimes looks/acts like a cache is more of a side effect.  
</p> 
<p>
</p> 

<h2>10: Id Generation 
</h2> 
<ul><li>DB Identity / Autoincrement</li>
<li>DB Sequences</li>
<li>UUID</li>
<li>Custom ID Generation</li>
</ul> 
<p>There are 4 ways that ID's can be automatically generated for new Entities. This occurs when a entity is going to be inserted and it does not already have an Id value.
</p> 
<p>The first 3 options are highly recommended for 2 reasons.  
</p> 
<p>1) They are standard approaches that can also be used by other programs, stored 
</p> 
<p>procedures, batch loading jobs etc that could be written in other languages etc. That is, if you choose a custom ID Generation then this can make it more difficult to use other programs / tools to insert into the DB.
</p> 
<p>2) They support good concurrency – can you really do better?
</p> 
<p>Most Databases support Sequences or Identity/Autoincrement. DB2 and H2 support both.
</p> 
<h2>10.1: UUID Id Generation
</h2> 
<p>To use UUID's with Ebean all you need to do is use the UUID type for your id property. Ebean will automatically assign an appropriate UUID Id generator.
</p> 
{% highlight java %}@Entitypublic class MyEntity {
@Id
UUID id;
    ...
{% endhighlight %} 
<p>
</p> 
<h2>10.2: DB Sequences / DB Autoincrement 
</h2> 
<p>Refer:  com.avaje.ebean.config.dbplatform.DatabasePlatform &amp; DbIdentity
</p> 
<p>For each database type (Oracle, MySql, H2, Postgres etc) there is a specific DatabasePlatform which defines whether the database supports sequences or autoincrement. This then defines whether DB sequences or DB Identity / Autoincrement will be used. This also provides a sequence generator specific to that database.
</p> 
<p>For DB sequences the NamingConvention is used to define the default name of the sequences. This name will be used unless the sequence name is explicitly defined via annotations.  
</p> 
<p>What this means is that, typical y you only need to the the @Id annotation unless you need to override a sequence name (when it doesn't match the naming convention).
</p> 
{% highlight java %}@Entity
public class MyEntity {
@Id
Integer id;
    ...
{% endhighlight %} 
<h2>10.3: Batched fetch of Db Sequences
</h2> 
<p>For performance reasons we don't want to fetch a sequence value each time we want an Id. Instead we fetch a 'batch' of sequences  (refer to ServerConfig setDatabaseSequenceBatchSize() ) - the default batch size is 20.
</p> 
<p>Also note that when the number of available Id's for a given sequence drops to half the batch size then another batch of sequences is fetched via a background thread.
</p> 
<p>For Oracle, Postgres and H2 we use Db sequences. It is worth noting that this al ows the use of JDBC batch statements (PreparedStatement.addBatch() etc) which is a significant performance optimization. You can global y turn on the use of JDBC batching via ServerConfig.setUsePersistBatching() … or you can turn it on for a specific Transaction. 
</p> 
<p>
</p> 

<h2>13: Data Types
</h2> 
<ul><li>Compound Types</li>
<li>Scalar Types</li>
<li>Enum</li>
<li>Boolean</li>
<li>Date / Timestamp / util Date / util Calender</li>
</ul> 
<p>Defining / Registering a new Scalar Type 
</p> 
<p>
</p> 
<h2>14: Field Access and Property Access
</h2> 
<p>Field and Property access are the two ways in which a field/property is managed/intercepted. What this means is that the ORM needs to intercept the reading or writing of either Fields or Properties.
</p> 
<p>An ORM does this interception to provide lazy loading and dirty checking functionality and an ORM achieves this using either Enhancement or Subclass generation (Subclass generation is also referred to as "Proxy classes").
</p> 
<p>To explain Field Access and Property Access I'll use an example focusing on a single field (in this case "firstName") and how Property Access and Field Acccess works in Ebean.
</p> 
{% highlight java %}...
@Entity
public class Person {
@Id
int id;
String firstName;
String lastName;
...
// An extra method... NOT a getter...
// here to highlight the difference between
// Field and Property Accesspublic String getFullName() {
return firstName + " " + lastName;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
// getters and setters for id and lastName not shown...
...
{% endhighlight %} 
<p>
</p> 
<h2>14.1: Property Access
</h2> 
<p>By "Property" we really mean a Java Bean Property. In the case of the "firstName" property this means the related getter and setter methods of getFirstName() and setFirstName(...). Refer to the Java Bean naming convention for clarification.
</p> 
<p>With Property Access you <i><b>MUST</b></i> have a setter and a getter.
</p> 
<p>With Property Access <i><b>ONLY</b></i> the getter and setter are intercepted. If you use the field in other methods then access to that field is not intercepted/managed (See the getFullName() method as an example).
</p> 
<h2>14.1.1:  Property Access with Ebean ...
</h2> 
<p>
</p> 
{% highlight java %}...
public String getFullName() {
// not getter or setter so NOT intercepted...
return firstName+" "+ lastName;
}
public String getFirstName() {
_ebean_intercept.preGetter("firstName");
return firstName;
}
public void setFirstName(String newValue) {
  _ebean_intercept.preSetter("firstName", newValue, getFirstName());
  this.firstName = newValue;
}
{% endhighlight %} 
<p>This is an example of how Ebean modifies/generates code to support "property access" (NB: other ORMs could generate quite different code).
</p> 
<p>The modified/generated class now has a <i><b>_ebean_intercept</b></i> field.
</p> 
<p>In calling getName() the preGetter() method is cal ed on the intercept field and this will invoke lazy loading if required.
</p> 
<p>In calling setName() getName() is called which in turn can invoke lazy loading. The getName() returns the "Old Value" / "Previous Value" of the name. The preSetter() method is called on the intercept and will maintain the "Dirty Checking" information.
</p> 
<p>If your entity beans just have getter and setter methods they are wel  suited to property access. From a design perspective they may also be cal ed "Anemic" in the sense that 
</p> 
<p>
</p> 
<p>they don't have any logic and can almost be viewed as pure data. 
</p> 
<h2>14.2: Field Access
</h2> 
<p>Field access in general is implemented via bytecode Enhancement (Also refered to as Weaving and Transformation).
</p> 
<p>The class bytes are modified replacing the GETFIELD and PUTFIELD bytecode cal s to "persistent fields" with method calls. 
</p> 
<p>With Ebean Field access looks something like this... (note: other ORMs could generate quite different code)
</p> 
{% highlight java %}public String getFullName() {
// GETFIELD firstName replaced...
return _ebean_getFirstName()+" "+_ebean_getLastName();
}
public String getFirstName() {
// GETFIELD firstName replaced
return _ebean_getFirstName();
}
public void setFirstName(String newValue) {
// PUTFIELD firstName replaced
_ebean_setFirstName(newValue);
}
// new method generated by Ebean
// used to replace GETFIELD firstName
String _ebean_getFirstName() {
_ebean_intercept.preGetter("firstName");
return this.firstName;
}
// new method generated by Ebean
// used to replace PUTFIELD firstName
void _ebean_setFirstName(String newValue) {
String currentValue = _ebean_getFirstName();
_ebean_intercept.preSetter("firstName", newValue, currentValue);
this.firstName = newValue;
}
{% endhighlight %} 
<p>With Field access it actually doesn't matter where the field is used the GETFIELD and PUTFIELD byte code instructions are replaced. It is important to note that in the example 
</p> 
<p>
</p> 
<p>above the getFullName() method is also modified to support the interception/mangement by the ORM.
</p> 
<p>Unlike property access field access <i><b>does not require</b></i> the getter or setter to even exist – they can be removed if you want.   
</p> 
<p>Essential y with Field access you can write whatever code you like (within reason) and it will behave as expected (ORM interception occuring as and how you would expect).
</p> 
<h2>14.2.1:  JPA – Choose access approach on a per Field / Property basis
</h2> 
<p>With JPA you choose between field or property access on a per field / property basis. If you put the annotation on the field this implies that you want field access and if you put the annotation on the associated getter method of the property then you should get property access.
</p> 
<p><i><b>Ebean does not work this way!!!</b></i>
</p> 
<h2>14.2.2:  Ebean – Field vs Property access
</h2> 
<p>Ebean has not fol owed the JPA approach. With Ebean you get Field Access when you use Enhancement and you get Property Access when you use Subclassing.
</p> 
<p>The reason for this comes down to...
</p> 
<ul><li>Keeping things simple</li>
<li>Field Access is the preferred approach </li>
<li>Subclassing approach introduces security / visibility issues for Field Access </li>
</ul> 
<p>In fact when building Ebean v0.9.8 I was personally pretty keen to do away with Property access altogether. This would have meant also removing support for the Subclassing approach. This would have meant making Ebean internal y simplier... 
</p> 
<p>... but I got talked out of it...
</p> 
<p>There are a few downsides to Field Access.
</p> 
<ul><li>Serialization: Your entity beans now include and depend on Ebean objects. Where you deserialize them you will need some Ebean classes in you class path.</li>
<li>Using JAVAAGENT or ANT or ...  to support the enhancement can be a pain. Ebean has tried to make this as simple and robust as possible. </li>
<li>Java Web Start does not support JAVAAGENT. However, you could enhance the classes at build time using an ANT task.</li>
</ul> 
<p>
</p> 
<h2>14.2.3:  Ebean interception notes
</h2> 
<b>Id Interception
</b> 
<p>Id fields/properties are not intercepted ever (either for reading or writing). That is, getting or setting an ID will never invoke lazy loading or cause the entity to be marked as dirty.
</p> 
<b>OneToMany and ManyToMany Interception
</b> 
<p>The List Set and Map persistent properties are not intercepted when they are being set. That is, setting a associated many property does not invoke lazy loading or mark the entity as dirty. 
</p> 
<p>When you get a entity back from a query every associated many property (List Set or Map) will have a 'proxy' in place. It is not until you invoke a method on the List Set or Map proxy that lazy loading of that proxy will occur.
</p> 
<p>A reference object (obtained by Ebean.getReference()) will lazy load the entity bean if a List Set or Map associated many property is read (via getter etc).
</p> 
<b>toString() interception
</b> 
<p>No interception is invoked by a toString() method. The reason for this decision is that toString() is often invoked by an IDE while running a debugger – in the past this has lead to confusion to have lazy loading being invoked accidental y in this fashion.  
</p> 
<b>equals() and hashCode() generation
</b> 
<p>If your entity bean does not have a equals() or hashCode() method then one will be generated for you based on the identity property using the "" technique.
</p> 
<p>The generated equals() or hashCode() methods do not invoke lazy loading. 
</p> 
<b>@Transient on methods
</b> 
<p>If you are using Ebean enhancement (Field Access) then you can put the @Transient annotation on a method and it is <i><b>NOT</b></i> intercepted. Specifically the method is left exactly as it is (rather than having the GETFIELD PUTFIELD byte codes replaced with intercepted method cal s).
</p> 
<p>This is an Ebean extension to the JPA spec. This enables you to write a method on an entity bean that you know will not have its field access intercepted.
</p> 
<h2>14.2.4:  Rob Opinion: The future is Field Access... lets make it work
</h2> 
<p>I'm a fan of Field Access in that a developer can write their entity bean however they like (except Ebean still requires a default constructor). You can write any type of business logic into your Entity bean and it will work correctly (in terms of ORM lazy loading and dirty 
</p> 
<p>checking).
</p> 
<p>Enhancement is the natural way to support field access so I believe it's Ebean's job to make Enhancement easy work for the developers (ANT tasks, IDE Integration as well as JAVAAGENT support).
</p> 
<p><b>Q:</b> JPA supports the mixing of Field and Property access on the same entity bean. will Ebean look to support this?
</p> 
<p><b>A:</b> No. If you can do field access then you should. On the web there is mention of benefits to using Property access such as performance and type conversion benefits. None of these apply to Ebean. I see no justification or benefits to mixing the access type but I do see problems and confusion, so there is no plan to mix the access types on a single entity bean.
</p> 
<p><b>Q:</b> So why does Ebean support Property Access again?
</p> 
<p><b>A:</b> Because Ebean supports the Subclassing approach (also known as "Dynamic Proxy approach"). The Subclassing approach lends itself to Property access due to the fact that the generated subclass is defined in a different ClassLoader to the original Class. This means that in a normal java environment that generated subclass can not access the non-public fields of the original class. 
</p> 
<p><b>Q:</b> How does the enhancement work for with Groovy or Scala entity beans?
</p> 
<p><b>A:</b> You can use Ebean enhancement on Groovy or Scala beans. Note this includes support for Scala's properties (which don't fol ow the Java Bean Spec getter setter method naming conventions). Ebean can tel  if it is a Groovy bean or Scala bean and take that into account as needed.
</p> 
<p>
</p> 
<h2>15: Enhancement and Subclass Generation
</h2> 
<p>There are two main techniques used by Java ORM vendors to support their features.
</p> 
<p>1. Enhancement (aka Weaving) – using a javaagent or an ANT task etc to enhance 
</p> 
<p>the classes prior to class loading (at load time or build time). 
</p> 
<p>2. Subclass Generation (aka Dynamic Proxy) - Using a ClassLoader internal to the 
</p> 
<p>ORM and generating Subclasses of your entity beans dynamically (also known as the "Dynamic Proxy" approach). 
</p> 
<p>Ebean supports both approaches.
</p> 
<p>Both of these approaches have their pros and cons. This section is aimed at explaining the two approaches and how they work in Ebean so that you can make an informed choice.
</p> 
<p>Ebean supports Enhancement / Weaving  via javaagent, ant task and an Eclipse IDE plugin. When Ebean starts up Ebean will check if the entity classes are enhanced and if not will automatical y generate a Subclass and use that instead.
</p> 
<p><i><b>Rob Opinion:</b></i> I believe the enhancement approach will be the better approach over the long term with less restrictions on the code. You don't need getters or setters and enhanced classes allowing any logic to be put into the entity beans (you need to be more careful with the Subclass generation approach).
</p> 
<h2>15.1: Why are these techniques needed?  
</h2> 
<p>Al  the Java ORM's that I am aware of need this to support "Lazy Loading" and that includes Ebean.
</p> 
<p>In addition to that Ebean (and some other ORMs) use these techniques to support "Dirty Checking" / "Optimistic Concurrency Checking". That is, detecting when an entity bean has been modified (made dirty) and maintaining original values to support Optimistic Concurrency Checking.
</p> 
<p>In short, ORMs use these techniques to intercept cal s to getters, setters and other methods to magical y invoke lazy loading as required and maintain "Dirty Checking" information. These techniques (Enhancement and Subclass generation) enable this magic to occur.
</p> 
<h2>15.2:  Why are these techniques popular?
</h2> 
<p>The reason this is a popular approach is that your entity beans do not need to implement any special interface or extend any special class. 
</p> 
<p>
</p> 
<p>In this example Person does not extend a special class or implement a special interface.
</p> 
{% highlight java %}package model;
import java.sql.Date;
import javax.persistence.Entity;import javax.persistence.Id;
@Entity
public class Person {
@Id
int id;
String firstName;
String lastName;
Date dob;
public int getId() {
return id;
}
public void setId(int id) {
this.id = id;
}
public String getFirstName() {
return name;
}
public void setFirstName(String name) {
this.name = name;
}
...
}
{% endhighlight %} 
<h2>15.3: ... and in Eclipselink, OpenJPA and Hibernate
</h2> 
<p><i><b>Rob Opinion:</b></i> It is my understanding/opinion as at May 10 that ...
</p> 
<p>Eclipselink doesn't support the Subclassing approach. This is interesting because I'd guess this project has the most resources behind it and it is the JPA 2.0 reference implementation. 
</p> 
<p>OpenJPA supports both approaches but strongly suggests to users to use Enhancement approach (javaagent or ant) for production deployment.
</p> 
<p>Hibernate supports both approaches but IMO the majority of hibernate users will be using the Subclassing approach. This is possibly because it is simplier where you don't have to 
</p> 
<p>
</p> 
<p>muck around with javaagent or ant etc.
</p> 
<p>In my opinion, the reason many people dislike the Enhancement approach (via javaagent or ant task etc) is because many have had problems getting this to work (trouble configuring and using javaagent, finding configuration files etc)... or because it slows down the... code – compile – run cycles (you have to run the ant task or make sure a javaagent is configured etc). In my opinion the Eclipse Ebean Enhancer plugin provides a good solution in that the classes are enhanced transparently whenever you save in the IDE. This is the approach I recommend for Eclipse users of Ebean.
</p> 
<p>Note that there is also an IDEA enhancer for Ebean so please ask for that if required.
</p> 
<h2>15.4: Subclass Generation
</h2> 
<p>Subclass generation is a technique made popular by Hibernate and also supported in OpenJPA and Ebean.
</p> 
<p>How this works in Ebean is that for each entity bean a new class is generated that is a subclass of that entity bean.
</p> 
<p>For the Person entity a subclass Person$$EntityBean would be generated...
</p> 
{% highlight java %}package model;
...
import com.avaje.ebean.bean.EntityBean;
public class Person$$EntityBean extends Person implements EntityBean
{
...
{% endhighlight %} 
<p>
</p> 
<p>The bytes for the Person$$EntityBean class are generated by Ebean and then defined using a ClassLoader.
</p> 
<p><b>Note:</b> When you query the ORM returning a Person you actual y get a Person$$EntityBean class. This can confuse people.
</p> 
{% highlight java %}Person p = Ebean.find(Person.class, 1);
System.out.println("vanilla: "+Person.class.getName());System.out.println("subclass:"+p.getClass().getName());
{% endhighlight %} 
<p>
</p> 
<p>output:
</p> 
<b>vanilla:  app.data.Personsubclass: app.data.Person$$EntityBean$testdb
</b> 
<p><b>Note:</b> The ClassLoader that defines the Person$$EntityBean class is not the same ClassLoader than loaded the Person class. This can lead to visibility and security issues such as Person$$EntityBean not being able to see fields or methods in Person.
</p> 
<p><i><b>This is essentially why with Ebean the subclassing approach uses Property access and not field acccess.</b></i>
</p> 
{% highlight java %}Bug bug = Ebean.find(Bug.class, 1);
System.out.println("ClassLoaders...  ");
System.out.println("vanilla:  "+Bug.class.getClassLoader());
System.out.println("subclass: "+bug.getClass().getClassLoader());
{% endhighlight %} 
<p>output:
</p> 
{% highlight java %}ClassLoaders...
vanilla:  sun.misc.Launcher$AppClassLoader@11b86e7
subclass: com.avaje.ebean.enhance.subclass.SubClassFactory@1db7df8
{% endhighlight %} 
<p>
</p> 
<h2>15.4.1:  Ebean's  Subclass Generation – Property access
</h2> 
<p>As part of the initialisation of an EbeanServer it gathers all the meta data about al  the entity beans etc. As part of this process for each entity bean Ebean checks to see if the class is already enhanced.  If the class implements the EntityBean interface then it has already been enhanced via javaagent, ant, Eclipse Ebean Enhancer plugin etc.
</p> 
<p>If the class has not been enhanced then Ebean will generate a subclass of that entity bean type. In the case of the Person entity bean this would look something like...
</p> 
<p> 
</p> 
{% highlight java %}package model;
...
import com.avaje.ebean.bean.EntityBean;
public class Person$$EntityBean extends Person implements EntityBean {
// intercept field is addedEntityBeanIntercept _ebean_intercept;...
public Person$$EntityBean() {
super();
_ebean_intercept = new EntityBeanIntercept(this);
}
// property access is used
public String getFirstName() {
_ebean_intercept.preGetter("firstName");
return super.getFirstName();
}
// property access is used
public void setFirstName(String newValue) {
  _ebean_intercept.preSetter("firstName", newValue, getFirstName());
  super.setFirstName(newValue);
}
// Other property getters and setters ...
// Other methods added to implement EntityBean ...
public EntityBeanIntercept _ebean_getIntercept() { ... }
public Object _ebean_createCopy() { ... }
public void _ebean_setField(...) { ... }
public Object _ebean_getField(...) { ... }
...
{% endhighlight %} 
<p>Note that when the subclass is generated Property access is used (Field access is not available for subclass generation in Ebean). The reason for this is that the Person$$EntityBean.class is defined in a different ClassLoader to that of the Person.class – and by default Java security restricts access by Person$$EntityBean to the public and protected fields and methods of Person.class.
</p> 
<p>That is, Person$$EntityBean is in a different "Runtime Package" as per JVM spec.
</p> 
<p>
</p> 
<p><i>"At run time, a class or interface is determined not by its name alone, but by a pair: its  fully qualified name and its defining class loader. Each such class or interface belongs to a single runtime package. The runtime package of a class or interface is determined by  the package name and defining class loader of the class or interface."</i>
</p> 
<p><a href="http://java.sun.com/docs/books/jvms/second_edition/html/ConstantPool.doc.html#72007"><i>http://java.sun.com/docs/books/jvms/second_edition/html/ConstantPool.doc.html#72007</i></a>
</p> 
<p><a href="http://java.sun.com/docs/books/jvms/second_edition/html/ConstantPool.doc.html#75929"><i>http://java.sun.com/docs/books/jvms/second_edition/html/ConstantPool.doc.html#75929</i></a>
</p> 
<p>The <i><b>big upside</b></i> of the subclass generation approach is that there is no "configuration" required – no javaagent or ant task to execute. You can just write you entity beans and test them.
</p> 
<p>The <i><b>big downside</b></i> of this approach is that Ebean's implementation uses Property access. That is, field access is not available with subclass generation due to JVM security. 
</p> 
<p><i><b>Rob Opinion:</b></i> Subclass Generation is easy to get working (no javaagent setup etc)... but I personal y feel that Field access is the better approach long term – specifically al owing more freedom in how the entity beans are coded. In my opinion it's a matter of making the enhancement process easy to use. The Eclipse IDE plugin to automatically enhance the beans as they are saved is one way to make enhancement easy and I am keen to make that work well.
</p> 
<h2>15.5: Enhancement
</h2> 
<p>I am using the term "Enhancement" to cover all the ways (javaagent, ant, IDE plugin etc) that are used to modify the class in question – as opposed to generating a new class (subclass generation).
</p> 
<p>Other similar terms to Enhancement that are used around the place include Weaving, Transformation and byte code manipulation.
</p> 
<p>LTW – Load time weaving is used to refer to when the class manipulation occurs at "load time" typical y via javaagent compared with class manipulation occuring at "build time" typical y via an ANT task or IDE plugin.
</p> 
<p>In raw terms a class is just a byte[] and we are simply manipulating those bytes prior to the class being defined by its ClassLoader.
</p> 
<p>
</p> 
<h2>15.5.1:  Ebean's Enhancement – Field access
</h2> 
<p>The ANT Task, javaagent and the Eclipse IDE Enhancer plugin al  use the same enhancement code. 
</p> 
<b>Already Enhanced
</b> 
<p>As part of the enhancement Ebean detects if the bean has already been enhanced and if so will skip the enhancement. In this way it does not matter if you try to enhance a set of classes more than once or use a number of techniques (ANT Task,  Enhancer Plugin and javaagent).
</p> 
<b>Mixing Enhanced and Subclassed entity beans
</b> 
<p>You can general y use a mixture of enhanced and subclassed entity beans but it is not a recommended approach. This could happen if you use ANT to enhance some but not al  of the entity beans. The ones not enhanced will end up being "subclassed" (Any entity bean class that is not enhanced when an EbeanServer initialises will have a subclass generated for it).
</p> 
<p><i><b>However</b></i>, you can <i><b>NOT</b></i> use a mixture of enhanced and subclassed beans for a given inheritance hierarchy. For a given inheritance heirarchy al  the beans involved in that heirarchy need to be either enhanced or subclassed – not a mixture.
</p> 
<p>To avoid confusion it is recommended to use either Enhancement or Subclassing and not a mixture of both. Ebean will detect if there is a mixture of both and will log a warning.
</p> 
<p>Example: warning when some entity beans are enhanced and some are subclassed.
</p> 
{% highlight java %}...
INFO: Entities enhanced[3] subclassed[5]
{% endhighlight %} 
<p></b>WARNING: Mixing enhanced and subclassed entities. Subclassed</b>
</p> 
{% highlight java %}classes:[User, OrderStatus, BugDetail, TestEntity, Order]
...
{% endhighlight %} 
<p>
</p> 
<h2>15.5.2:  javaagent
</h2> 
<p>Examples where<a href="file:///D:/docs/jarlib/ebean-0.9.8.jar"> d:/jarlib/ebean-agent-2.0.0.jar </a>is the location of the ebean agent jar file...
</p> 
<p>-javaagent:d:/jarlib/ebean-agent-2.0.0.jar
</p> 
<p>-javaagent<a href="file:///D:/docs/jarlib/ebean-0.9.8.jar=debug=3">:d:/jarlib/ebean-agent-2.0.0.jar=debug=3</a>
</p> 
<p>-javaagent<a href="file:///D:/docs/jarlib/ebean-0.9.8.jar=debug=3">:d:/jarlib/ebean-agent-2.0.0.jar=debug=3;packages=app.data.*,org.test.model.*</a>
</p> 
<p>To use the javaagent approach you have to change the parameters passed to the JVM when it is started.
</p> 
<p><b>The Ebean javaagent can take 2 optional parameters:</b> 
</p> 
<p><b>debug:</b> An int between 0 and 10,  with 0 producing no output and 10 producing lots of debug output.
</p> 
<p><b>packages</b>: a comma delimited list of packages. This is used to speed up the processing by skipping transformation on any class not in one of the listed packages.
</p> 
<p>  
</p> 
<p>The following images shows the Eclipse run dialog with the Ebean java agent specified in the VM arguments.
</p> 
<p>
</p> 
<p><img src="ebean-userguide-89_1.jpg"/>
</p> 
<p><i><b>Rob Opinion:</b></i> The javaagent approach has 3 known critisims:
</p> 
<p><b>Criticism 1:</b> Slows the JVM Bootup – as every class is passed to transformers prior to being defined by the ClassLoaders. Ebean skips classes that are in well known packages such as known JDBC drivers, Sun classes, junit classes and common apache libraries. You can also use the packages parameter to only transform classes in those packages.
</p> 
<p><b>Criticism 2:</b> Not supported by Java Web Start. You have to use ANT or IDE Plugin for this scenario.
</p> 
<p><b>Criticism 3:</b> Not great in a Server setup like Tomcat. You really want to specify the javaagent on a per webapp basis rather than global y to the whole server. In the future I'm going to look at a specific Tomcat Loader to see if that is useful.
</p> 
<p>
</p> 
<h2>15.5.3:  ANT Task
</h2> 
<p>Modify your ant build.xml file to:
</p> 
<p>1. Define the AntEnhanceTask.
</p> 
<p>2. Create a target that uses the AntEnhanceTask to enhance the entity classes.
</p> 
{% highlight java %}<taskdef name="ebeanEnhance"
   classname="com.avaje.ebean.enhance.ant.AntEnhanceTask"
   classpath="your_path_to/ebean-x.x.x.jar" />
<target name="ormEnhance" depends="clean,compile">
    <!-- eg. enhance entities in packages below app.entity -->
    <ebeanEnhance classSource="your_classes_directory"
     packages="app.entity*"
     transformArgs="debug=5" />
</target>
{% endhighlight %} 
<p><b>classSource:</b> This is the directory that contains your class files. That is, the directory where your IDE will compile your java class files to, or the directory where a previous ant task will compile your java class files to.
</p> 
<p><b>classDest:</b> The directory where the enhanced classes are written to. If not specified this defaults to the classSource effectively replacing the original class file with the enhanced class file.
</p> 
<p><b>packages:</b> a comma delimited list of packages that contain entity classes. All the classes in these packages are searched for entity classes to be enhanced.
</p> 
<p><b>transformArgs:</b> This contains a debug level (0 - 10) .
</p> 
<b>Rob Opinion:  
</b> 
<p>The ANT Task is great. However, I personally found that using the ANT Task by itself was not satisfactory in that it negatively effected the ... CODE – COMPILE – RUN cycle.  That is, having to run the ANT task slows down that cycle and is general y a pain in this scenario.
</p> 
<p>I think it is more likely that the ANT Task will be used as part of the build process (building a jar or war for deployment) and other approaches such as the IDE Plugin are better suited to use during the actual development CODE – COMPILE – RUN process.
</p> 
<p>
</p> 
<p><img src="ebean-userguide-91_1.jpg"/>
</p> 
<h2>15.5.4:  Eclipse IDE – Configure Project JRE
</h2> 
<p>In Eclipse you can specify the javaagent parameter as the VM arguments in the run configuration. Eclipse – Run – Open Run Dialog – Arguments – VM Arguments.
</p> 
<p>However, you would need to do this for each class with a main() method that you want to run. This could be tedious if you have a lot of different classes with main() methods.
</p> 
<p>Another approach is to register a new "Installed JRE" with the javaagent parameter set as the default VM argument and then use this JRE for your project rather than a normal JRE.
</p> 
<p>Eclipse – Preferences – Java – Installed JREs – Add
</p> 
<p>–
</p> 
<p>Using the Browse button find a JRE (I'd find a JDK actually).
</p> 
<p>–
</p> 
<p>Enter the Default VM Arguments (-javaagent ...)
</p> 
<p>
</p> 
<p>
</p> 
<p>
</p> 
<p><img src="ebean-userguide-94_1.jpg"/>
</p> 
<p><img src="ebean-userguide-94_2.png"/>
</p> 
<p><img src="ebean-userguide-94_3.jpg"/>
</p> 
<p>Eclipse – project – Build Path – Configure Build Path ...
</p> 
<p>Libraries – Add Library – JRE System Library – Alternate JRE...
</p> 
<p>(Choose your JRE that has the javaagent configured)
</p> 
<p>You now have two JRE Libraries in your projects build path. Remove the original one leaving you with the one that has the javaagent configured.
</p> 
<p>Your project Build Path should now look something like this (below) where my JRE configured with the javaagent is cal ed "jdk1.5.0_03+ebeanAgent"
</p> 
<p>
</p> 
<p><img src="ebean-userguide-95_1.jpg"/>
</p> 
<p>Now, whenever you run a class with a main() method your javaagent is configured for you.
</p> 
<p>In the example above there is the "debug=1" parameter and with this you will see in the console (which shows the agent is being used) followed by enhancement debug output.
</p> 
{% highlight java %}
premain loading Transformer args:debug=1
{% endhighlight %} 
<p>
</p> 
<h2>15.5.5:  Eclipse IDE Enhancer Plugin
</h2> 
<p>The Eclipse Enhancer plugin enhances classes as they are saved by the Eclipse IDE. 
</p> 
<p>The benefit of using this approach is that you do not need to configure a javaagent nor do you need to remember to run an ANT task before running your application. That is, you can just code your entity beans and then run your code or junit tests.
</p> 
{% highlight java %}Install the plugin
Eclipse 3.4:
{% endhighlight %} 
<p>Help – Software Updates – Add Site -<a href="http://www.avaje.org/eclipseupdate/"> http://www.avaje.org/eclipseupdate/</a>
</p> 
<p>Manage Sites – Check the newly added site – OK
</p> 
<p>Check the<a href="http://www.avaje.org/eclipseupdate/"> http://www.avaje.org/eclipseupdate/ </a>site and fol ow the instructions.
</p> 
<p>Note: the trailing slash after eclipseupdate/ is required.
</p> 
<b>Using the Enhancer Plugin
</b> 
<p>You need to enable the Enhancer on a per project basis. To do this select a project – right mouse click menu – Toggle Enable/Disable Ebean Enhancement.
</p> 
<p>When you enable the Enhancer it adds a "Builder" to the list of "builders" ...
</p> 
<p>Select a project – right mouse click menu – properties – builders
</p> 
<p>When the enhancement is enabled you see 2 builders both enabled. The Java Builder and the Ebean Builder.
</p> 
<b>Preferences
</b> 
<p>There is a Ebean preference page added where you can set debug levels on the Enhancement process and the plugin itself.
</p> 
<b>How to tell if the Enhancement is occuring?
</b> 
<p>If the Plugin has initialised then project – right mouse click menu ... will show the menu item to be "Disable Ebean Enhancer" indicating that the enhancer is enabled on this project. If the Plugin has not yet been initialised then the menu item just shows "Toggle Ebean Enhancer" which will turn it on or off.
</p> 
<p>Turn on debugging and check the log files (Window – Preferences – Ebean)
</p> 
<p>The other option is to look at the logs that Ebean writes during its startup phase. Specifically it reports the number of entity beans that have been "enhanced" and the number that have been "subclassed" and will log a warning if you are using a mix of both.
</p> 
<p>In the following example log you can see that <i><b>34</b></i> classes where enhanced and <i><b>3 </b></i>were 
</p> 
<p>subclassed. It is recommended not to mix enhancement and subclassing though so when this mixing is detected a warning is displayed.
</p> 
<p>
</p> 
{% highlight java %}...
INFO: Validation: [on] autocreate.notnull=[true] ...  
INFO: Deployment xml [orm.xml]  loaded.
INFO: Entities enhanced[34] subclassed[3]
WARNING: Mixing enhanced and subclassed entities. Subclassed ... 
INFO: Transaction logs in: logs
INFO: Autofetch deserialized from file [...\ebean.mysql.autofetch]
...
{% endhighlight %} 
<p>
</p> 
<b>Specialised Tomcat Loader for per-webapp Enhancement
</b> 
<p>This is on the future development TODO list...
</p> 
<p>
</p> 
<h2>16: Groovy
</h2> 
<p>You can use Ebean with Groovy classes. There is nothing special you need to do. Just annotate your groovy beans with the JPA annotations.
</p> 
{% highlight java %}//GROOVY CODE (generates the getters and setters etc)package test
import javax.persistence.*;
@Entity@Table(name="f_forum")public class PersonG{
@Id Integer id
@Column(name="title")String name
@OneToMany(cascade=CascadeType.ALL)List<Topic> topics;
}
{% endhighlight %} 
<p>You can use Ebean just as you would in Java.
</p> 
{% highlight java %}// GROOVY CODEpackage test
import com.avaje.ebean.*
public class MainEbean{
public static void main(String[] args) {
PersonG g = Ebean.getReference(PersonG.class, 1);
String name = g.getName();
List<PersonG> list = Ebean
.find(PersonG.class).fetch("topics").findList()
{% endhighlight %} 
<p>
</p> 
{% highlight java %}println "Got list "+list
list.each() { 
print " ${it.id} ${it.name} \n" print " GOT DETAILS: "+it.topics
}; println "done";
}
}
{% endhighlight %} 
<p>Note that if you want more groovy integration please make some suggestions of what you would like to see.    
</p> 
<p>
</p> 
<h2>17: Scala
</h2> 
<p>You can use Ebean with Scala as well. Again, annotate your scala "bean" with the JPA annotations as you would normally. 
</p> 
<p>Ebean 2.6 has added support for Scala 2.8 mutable Buffer, Set and Map and Option types (you no longer have to use the Java col ection types).
</p> 
<p>Please contact the Ebean google group for the latest Scala examples.
</p> 
<p></body>
</p> 
<p></html>
</p>
